#!/usr/bin/env python2.7
#
# This file is part of Script of Scripts (sos), a workflow system
# for the execution of commands and scripts in different languages.
# Please visit https://github.com/bpeng2000/SOS for more information.
#
# Copyright (C) 2016 Bo Peng (bpeng@mdanderson.org)
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
#

import sys
import argparse

from pysos import SOS_VERSION, SOS_FULL_VERSION, env, sos_run, sos_show

def addCommonArgs(parser):
    parser.add_argument('-v', '--verbosity', choices=['0', '1', '2', '3', '4'],
            help='''Output error (0), warning (1), info (2), debug (3) and trace (4)
            information to standard output (default to 2).'''),

if __name__ == '__main__':
    master_parser = argparse.ArgumentParser(description='''A workflow system
            for the execution of commands and scripts.''',
        prog='sos',
        fromfile_prefix_chars='@',
        epilog='''Use 'sos cmd -h' for details about each subcommand. Please
            contact Bo Peng (bpeng at mdanderson.org) if you have any question.''')

    master_parser.add_argument('--version', action='version',
        version='%(prog)s {}'.format(SOS_FULL_VERSION))
    subparsers = master_parser.add_subparsers(title='subcommands')
    #
    # command run
    parser = subparsers.add_parser('run',
        help='Execute a SoS script')
    parser.add_argument('script', metavar='SCRIPT',
        help='A SoS script that defines one or more workflows.')
    parser.add_argument('workflow', metavar='WORKFLOW:STEPS', nargs='?',
        help='''Name of the workflow to execute. This option can be ignored if
            the script defines a default workflow (with no name or with name
            `default`) or defines only a single workflow. A comma separated
            list of steps (`n` for step `n`, `-n` for up to `n`, `n-` for `n`
            and later, `n-m` for `n` to `m`) can be appended to workflow name
            (separated by `:`) to list steps of workflow to execute. ''')
    parser.add_argument('-d', action='store_true', dest='__dryrun__',
        help='''Execute the workflow in dryrun mode. SoS executes the
            specified workflow one by one, evaluate all expressions and
            statements but skip any function call and do not raise any
            error for missing input or output files. Running a script
            in dryrun mode, especially in verbosity mode 3 can help you
            trace the input, output of steps and definition of variables.''')
    addCommonArgs(parser)
    parser.set_defaults(func=sos_run)
    #
    # command show
    parser = subparsers.add_parser('show',
        help='Show a SoS script')
##         help='Execute a pipeline or a SQL query',
##         description='''Execute a pipeline that uses external commands to
##             process input files, usually to align raw reads to a reference
##             genome and call variants from aligned reads. The pipelines are
##             controlled by pipeline description files. This command can also be
##             used to execute arbitrary SQL query against the project database.
##             Additional parameters will be passed to pipelines as pipeline
##             parameters. ''')
    parser.add_argument('script', metavar='SCRIPT',
        help='A SoS script')

    parser.add_argument('workflow', metavar='WORKFLOW:STEPS', nargs='?',
        help='Name of the workflow to execute')
    addCommonArgs(parser)
    parser.set_defaults(func=sos_show)
##     #
##     # getting args, some commands accept arbitrary arguments so we need to
##     # separate them into argv
##     #
##     # http://bugs.python.org/issue12353
##     # parse_known_args cannot handle arguments with empty string '', we need
##     # to manually change it to ' ' to get around of this problem.
##     # Hopefully this will not cause any trouble in later argument processing.
##     if '' in sys.argv:
##         for idx, arg in enumerate(sys.argv):
##             if arg == '':
##                 sys.argv[idx] = ' '
##     #
    args, argv = master_parser.parse_known_args()
    env.verbosity = args.verbosity
##     # python3 does not raise an error "too few arguments" when no argument is
##     # provided so we have to explicitly handle this case. The output of command
##     # vtools is therefore different in python 2 (error message) and 3 (help message).
##     if not hasattr(args, 'func'):
##         master_parser.print_help()
##         sys.exit(0)
##     # commands that accepts format and other subparsers can pass arbitrary
##     # parameter to subparsers
##     if args.func in [association.associate, importer.importVariants,
##         update.update, exporter.export, pipeline.execute, pipeline.simulate]:
##         args.unknown_args = argv
##     elif len(argv) > 0:
##         master_parser.print_usage(sys.stderr)
##         sys.exit('sos: error: unrecognized arguments: ' + ' '.join(argv))
    # calling the associated functions
    args.func(args, argv)
