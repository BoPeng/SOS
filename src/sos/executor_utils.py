#!/usr/bin/env python3
#
# Copyright (c) Bo Peng and the University of Texas MD Anderson Cancer Center
# Distributed under the terms of the 3-clause BSD License.

#
# Utility functions used by various executors.
#

import os

from typing import Any
from collections import Sequence, Iterable

from .targets import (RemovedTarget, file_target, path, BaseTarget,
    sos_targets, UnknownTarget, paths, dynamic)
from .utils import env
from .eval import SoS_eval


def __null_func__(*args, **kwargs) -> Any:
    '''This function will be passed to SoS's namespace and be executed
    to evaluate functions of input, output, and depends directives.'''
    def _flatten(x):
        if isinstance(x, str):
            return [x]
        elif isinstance(x, Sequence):
            return sum((_flatten(k) for k in x), [])
        elif hasattr(x, '__flattenable__'):
            return _flatten(x.flatten())
        else:
            return [x]

    return _flatten(args), kwargs

def clear_output():
    '''
    Remove file targets in `_output` when a step fails to complete
    '''
    for target in env.sos_dict['_output']:
        if isinstance(target, file_target) and target.exists():
            try:
                target.unlink()
                env.logger.warn(f'Removing {target} generated by failed step {env.sos_dict["step_name"]}.')
            except Exception as e:
                env.logger.warning(f'Failed to remove {target}: {e}')


def reevaluate_output():
    # re-process the output statement to determine output files
    args, _ = SoS_eval(
        f'__null_func__({env.sos_dict["step_output"]._undetermined})')
    if args is True:
        env.logger.error('Failed to resolve unspecified output')
        return
    # handle dynamic args
    args = [x.resolve() if isinstance(x, dynamic) else x for x in args]
    return sos_targets(*args, verify_existence=True)


def validate_step_sig(sig):
    if env.config['sig_mode'] == 'default':
        # if users use sos_run, the "scope" of the step goes beyong names in this step
        # so we cannot save signatures for it.
        if 'sos_run' in env.sos_dict['__signature_vars__']:
            return {}
        else:
            matched = sig.validate()
            if isinstance(matched, dict):
                env.logger.info(
                    f'``{env.sos_dict["step_name"]}`` (index={env.sos_dict["_index"]}) is ``ignored`` due to saved signature')
                return matched
            else:
                env.logger.debug(
                    f'Signature mismatch: {matched}')
                return {}
    elif env.config['sig_mode'] == 'assert':
        matched = sig.validate()
        if isinstance(matched, str):
            raise RuntimeError(
                f'Signature mismatch: {matched}')
        else:
            env.logger.info(
                f'Step ``{env.sos_dict["step_name"]}`` (index={env.sos_dict["_index"]}) is ``ignored`` with matching signature')
            return matched
    elif env.config['sig_mode'] == 'build':
        # build signature require existence of files
        if 'sos_run' in env.sos_dict['__signature_vars__']:
            return {}
        elif sig.write(rebuild=True):
            env.logger.info(
                f'Step ``{env.sos_dict["step_name"]}`` (index={env.sos_dict["_index"]}) is ``ignored`` with signature constructed')
            return {'input': sig.content['input'],
                'output': sig.content['output'],
                'depends': sig.content['depends'],
                'vars': sig.content['end_context']
                }
    elif env.config['sig_mode'] == 'force':
        return {}
    else:
        raise RuntimeError(
            f'Unrecognized signature mode {env.config["sig_mode"]}')


def verify_input():
    # now, if we are actually going to run the script, we
    # need to check the input files actually exists, not just the signatures
    for key in ('_input', '_depends'):
        for target in env.sos_dict[key]:
            if not target.target_exists('target'):
                raise RemovedTarget(target)
