#!/usr/bin/env python3
#
# Copyright (c) Bo Peng and the University of Texas MD Anderson Cancer Center
# Distributed under the terms of the 3-clause BSD License.

import glob
import os

from typing import Any
from collections import Sequence, Iterable

from .targets import (RemovedTarget, file_target, path, BaseTarget,
    sos_targets, UnknownTarget, paths, dynamic)
from .utils import env
from .eval import SoS_eval

def verify_input():
    # now, if we are actually going to run the script, we
    # need to check the input files actually exists, not just the signatures
    for key in ('_input', '_depends'):
        for target in env.sos_dict[key]:
            if not target.target_exists('target'):
                raise RemovedTarget(target)


def __null_func__(*args, **kwargs) -> Any:
    '''This function will be passed to SoS's namespace and be executed
    to evaluate functions of input, output, and depends directives.'''
    def _flatten(x):
        if isinstance(x, str):
            return [x]
        elif isinstance(x, Sequence):
            return sum((_flatten(k) for k in x), [])
        elif hasattr(x, '__flattenable__'):
            return _flatten(x.flatten())
        else:
            return [x]

    return _flatten(args), kwargs


def expand_file_list(ignore_unknown: bool, *args) -> sos_targets:
    ifiles = []

    for arg in args:
        if arg is None:
            continue
        elif isinstance(arg, BaseTarget):
            ifiles.append(arg)
        elif isinstance(arg, (str, path)):
            ifiles.append(os.path.expanduser(arg))
        elif isinstance(arg, sos_targets):
            ifiles.extend(arg.targets())
        elif isinstance(arg, paths):
            ifiles.extend(arg.paths())
        elif isinstance(arg, Iterable):
            # in case arg is a Generator, check its type will exhaust it
            arg = list(arg)
            if not all(isinstance(x, (str, path, BaseTarget)) for x in arg):
                raise RuntimeError(f'Invalid target: {arg}')
            ifiles.extend(arg)
        else:
            raise RuntimeError(
                f'Unrecognized file: {arg} of type {type(arg).__name__}')

    if ignore_unknown and all(isinstance(x, str) and '*' not in x for x in ifiles):
        # we are exclusind a case with
        #    output: *.txt, group_by
        # here but that case is conceptually wrong anyway
        return sos_targets(ifiles)
    # expand files with wildcard characters and check if files exist
    tmp = []
    for ifile in ifiles:
        if isinstance(ifile, BaseTarget):
            if ignore_unknown or ifile.target_exists():
                tmp.append(ifile)
            else:
                raise UnknownTarget(ifile)
        elif file_target(ifile).target_exists('target'):
            tmp.append(ifile)
        elif file_target(ifile).target_exists('any'):
            env.logger.debug(
                f'``{ifile}`` exists in zapped form (actual target has been removed).')
            tmp.append(ifile)
        elif isinstance(ifile, sos_targets):
            raise ValueError("sos_targets should not appear here")
        else:
            expanded = sorted(glob.glob(os.path.expanduser(ifile)))
            # no matching file ... but this is not a problem at the
            # inspection stage.
            #
            # NOTE: if a DAG is given, the input file can be output from
            # a previous step..
            #
            if not expanded:
                if ignore_unknown:
                    tmp.append(ifile)
                else:
                    raise UnknownTarget(file_target(ifile))
            else:
                tmp.extend(expanded)
    return sos_targets(tmp)

def clear_output():
    for target in env.sos_dict['_output']:
        if isinstance(target, file_target) and target.exists():
            try:
                target.unlink()
                env.logger.warn(f'Removing {target} generated by failed step {env.sos_dict["step_name"]}.')
            except Exception as e:
                env.logger.warning(f'Failed to remove {target}: {e}')



def validate_step_sig(sig):
    if env.config['sig_mode'] == 'default':
        # if users use sos_run, the "scope" of the step goes beyong names in this step
        # so we cannot save signatures for it.
        if 'sos_run' in env.sos_dict['__signature_vars__']:
            return {}
        else:
            matched = sig.validate()
            if isinstance(matched, dict):
                env.logger.info(
                    f'``{env.sos_dict["step_name"]}`` (index={env.sos_dict["_index"]}) is ``ignored`` due to saved signature')
                return matched
            else:
                env.logger.debug(
                    f'Signature mismatch: {matched}')
                return {}
    elif env.config['sig_mode'] == 'assert':
        matched = sig.validate()
        if isinstance(matched, str):
            raise RuntimeError(
                f'Signature mismatch: {matched}')
        else:
            env.logger.info(
                f'Step ``{env.sos_dict["step_name"]}`` (index={env.sos_dict["_index"]}) is ``ignored`` with matching signature')
            return matched
    elif env.config['sig_mode'] == 'build':
        # build signature require existence of files
        if 'sos_run' in env.sos_dict['__signature_vars__']:
            return {}
        elif sig.write(rebuild=True):
            env.logger.info(
                f'Step ``{env.sos_dict["step_name"]}`` (index={env.sos_dict["_index"]}) is ``ignored`` with signature constructed')
            return {'input': sig.content['input'],
                'output': sig.content['output'],
                'depends': sig.content['depends'],
                'vars': sig.content['end_context']
                }
    elif env.config['sig_mode'] == 'force':
        return {}
    else:
        raise RuntimeError(
            f'Unrecognized signature mode {env.config["sig_mode"]}')


def reevaluate_output():
    # re-process the output statement to determine output files
    args, _ = SoS_eval(
        f'__null_func__({env.sos_dict["step_output"]._undetermined})')
    if args is True:
        env.logger.error('Failed to resolve unspecified output')
        return
    # handle dynamic args
    args = [x.resolve() if isinstance(x, dynamic) else x for x in args]
    return expand_file_list(True, *args)
